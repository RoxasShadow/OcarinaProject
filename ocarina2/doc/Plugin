Un plugin consente di estendere le funzionalità di Ocarina, implementando nuove funzioni.
Di seguito un breve tutorial pratico per lo sviluppo e l'installazione.

1. Il file plugins.cfg
	Il file plugins.cfg (/plugin/plugins.cfg) consente di monitorare i plugin attivi
	e di ottenere eventuali informazioni su ognuno di essi.
	Quando si installa un nuovo plugin, bisogna aggiungere una nuova sezione al file.
	Un esempio per il plugin `Today` potrebbe essere il seguente.
	
		name = HelloWorld
		version = 1.0
		author = Giovanni Capuano
		website = www.giovannicapuano.net
		description = Saluta il mondo!
		path = ./plugin/plugins/HelloWorld/hello.php
		enabled = true
	
		name = Today
		version = 1.0
		author = Your Name
		website = www.yoursite.me
		description = Today ti permette di scoprire quale giorno è oggi.
		path = ./plugin/plugins/Today/today.php
		enabled = true
		
	Nella prima riga abbiamo un il nome con cui viene individuato il plugin, la versione, l'autore,
	il suo sito web (privo della dichiarazione del protocollo), una breve descrizione delle sue
	funzionalità, il percorso assoluto e infine lo stato, `true` se attivo, `false` se disattivo.
	
2. Il plugin
	Ora procediamo a creare il plugin vero e proprio, che altro non farà che visualizzare
	un utente a caso al visitatore.
	Creiamo quindi una cartella chiamata `ChiTiPensa` in /plugin/plugins/, nel quale creiamo un
	file vuoto chiamato `chitipensa.php`.
	Procediamo con lo scrivere il codice.
	
	<?php
	class ChiTiPensa extends User implements FrameworkPlugin {
		private $rendering = array();
	
		public function main($templateVarList) {
			$userList = parent::getUser();
			$nickname = ($userList) ? $userList[rand(0, parent::countUser()-1)]->nickname : '';
			$chitipensa = ($nickname !== '') ? '<a href="'.$this->config[0]->url_index.'/profile/'.$nickname.'.html">'.$nickname.'</a>!' : 'Nessuno! Qui non c\'è anima viva D:';
			$this->rendering['postmenu'] = $templateVarList['postmenu'].'<div align="center">L\'utente fortunato di oggi è... '.$chitipensa.'</div>';
			return $this->rendering;
		}
	}
	
	Come possiamo vedere, abbiamo dato alla classe lo stesso nome del plugin.
	Dichiariamo per prima cosa un array vuoto e il metodo `main()`, quello principale,
	con argomento un array associativo contenente i nomi dei tag creati e il loro valore.
	Utilizziamo il metodo della classe User `getUser()` per ottenere un oggetto contenente gli utenti registrati.
	Controlliamo se l'oggetto è vuoto.
	In caso contrario, creiamo la variabile `$nickname` dove con un numero casuale tra 0 e il numero
	di utenti, otteniamo un nickname, che poi incorporiamo in un link, altrimenti comunichiamo che
	non c'è alcun utente registrato.
	Creiamo poi un nuovo elemento dell'array `rendering`, in cui appendiamo al tag `postmenu` il messaggio da inviare.
	Infine ritorniamo al motore di elaborazione dei plugin l'array puntante a `postmenu`, che provvederà
	alla modifica del tag e alla renderizzazione.
	
In questo caso, la superclasse a cui facciamo riferimento è `User`, e accediamo ai suoi metodi tramite la parola chiave `parent::`.
Attenzione però di non esagerare!
Infatti ogni qual volta utilizziamo l'ereditarietà, le prestazioni globali diminuiscono, dal momento che si viene a creare una nuova istanza della gerarchia di classi, con conseguente overhead.
Inoltre sono a disposizione dei plugin dei specifici tag nei template, dove inserire eventuali righe HTML.
Questi tag sono:
	`head` -> Prima della chisura del tag head
	`body` -> Subito prima dei contenuti
	`menu` -> Subito prima del menù
	`postmenu` -> Subito dopo il menù
	`stats` -> Le statistiche del sito
	`footer` -> Prima della chiusura del tag body

Insomma, possiamo fare di tutto, dal prelevare dati dal database, a creare nuovi tipi di contenuti.
L'importante è stare attenti a creare plugin sicuri e veloci, il solo limite è la fantasia!
